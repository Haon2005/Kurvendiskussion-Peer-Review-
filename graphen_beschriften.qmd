---
title: "Graphen beschriften"
format: html
filters:
  - pyodide
---

# Graphen beschriften

Willkommen zum **Abschlusskapitel!**  
 Hier wird alles aus den vorherigen Abschnitten zusammengefasst und verarbeitet. Unser Ziel ist es, ein einziges, leistungsfähiges Python-Programm zu entwickeln, das eine Funktion umfassend analysiert und alle wichtigen Merkmale – Achsenschnittpunkte, Extrema, Wendepunkte und Asymptoten – in einem einzigen, übersichtlichen Graphen darstellt.

---

## Schritt 1: Das Grundgerüst – Eine Funktion plotten

Alles beginnt mit der Fähigkeit, eine Funktion grafisch darzustellen. Hier kann das Wissen aus dem Abschnitt [Graphen erstellen](graphen.qmd) helfen, um eine Basis zu schaffen.

::: {.callout-note title="Erinnerung: Graphen erstellen" collapse="true"}
Im Abschnitt [Graphen erstellen](graphen.qmd) haben wir gelernt, wie man eine Funktion mit `numpy` und `matplotlib` plottet. Der grundlegende Ablauf war:

1.  Variablen/ Funktion mit `sympy` definieren.
3.  Mit `numpy.linspace` eine Reihe von x-Werten erzeugen.
4.  Die y-Werte berechnen.
5.  Mit `matplotlib.pyplot.plot` den Graphen zeichnen.
:::

---

### Plotten der Basisfunktion

Ein kleiner Startcode von dem aus Du den Rest des Kapitels erarbeiten sollst (mit Tipps natürlich!).

<details>
<summary> Hier klicken um den Startcode anzuzeigen </summary>

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import sympy
x = sympy.symbols('x')
f = x**3 - 6*x**2 + 9*x

f_str="x**3 - 6*x**2 + 9*x"
f_sym = sympy.sympify(f_str) #simpify macht aus einem String eine sympy Funktion
f_np = sympy.lambdify(x, f_sym, 'numpy')#lambdify macht aus einer sympy Funktion eine numpy Funktion (damit können Rechnungen deutlich schneller durchgeführt werden)

x_vals = np.linspace(-1, 5, 400)
y_vals = f_np(x_vals)
plt.plot(x_vals, y_vals)
plt.title('Basisfunktion')
plt.xlabel('x-Achse')
plt.ylabel('y-Achse')
plt.grid(True)
plt.show()
```

</details>

::: {.callout-note title="Hinweis zu unterschiedlichen Objektformen in Python" collapse="true"}
Im obigen Code sind alle in diesem Tutorial vorgekommenen Varianten eine Funktion in Python einzuspeisen nochmal aufgeschrieben.  
Ein Überblick was die unterschiedlichen Objekte für Vor-/Nachteile haben.  

*   `String Objekt:` Ein String ist eine Aneinanderreihung von Zeichen, d.h. wenn die Funktion angegeben wird, ist sie wie ein beliebiges Wort für Python. 
     * Dies ist vor allem (was leider in diesem Tutorial nicht gemacht werden kann) wichtig, wenn es darum geht eine Eingabe des Nutzers außerhalb des Codes abzufragen. D.h. wenn ich will das der Nutzer vom Programm die Frage gestellt bekommt "Welche Funktion willst du untersuchen?" Der Nutzer kann dann die Funktion im Terminal eingeben und diese Eingabe kann als String in Python ausgelesen werden und dem Nutzer nach Durchlauf des Programms alle relevanten Eigenschaften der Funktion anzeigen. 
*   `Sympy Objekt:` Mit einer Funktion die so in Python gespeichert ist kann algebraisch gearbeitet werden, heißt damit können Nullstellen berechnet, Ableitungen bestimmt etc. werden.
*   `Numpy Objekt:`  Mit einer so gespeicherten Funktion kann sehr gut gerechnet werden, hier wird die Funktion in effektiver vektorschreibweise gespeichert damit Rechnungen möglichst effektiv durchgeführt werden können.

```{pyodide-python}
x = sympy.symbols('x') 
f = x**3 - 6*x**2 + 9*x
```

Diese Variante wurde häufig im Tutorial genutzt, f ist hierbei ein sympy Objekt, da in der Variable f eine Variable vorkommt die vorher explizit als Sympy Variable definiert wird.  

```{pyodide-python}
f_str="x**3 - 6*x**2 + 9*x"
```

In diesem Fall ist f_str eine Funktion die als String gespeichert ist.
```{pyodide-python}
f_str="x**3 - 6*x**2 + 9*x"
f_sym = sympy.sympify(f_str) 
```

Durch `sympy.sympify` wird aus dem String ein Sympy Objekt (identisch mit dem ersten Beispiel) erstellt.
```{pyodide-python}
f_np = sympy.lambdify(x, f_sym, 'numpy')  
```

`sympy.lambdify` ist eine Art Übersetzer mit dem Objekte in einen anderen Objekttypen verwandelt werden, in diesem Fall wird $f_{sym}$ basierend auf der Variable x in `numpy` übersetzt, dass heißt $f_{np}$ ist ein `numpy-Objekt`.  

:::

---

## Schritt 2: Besondere Punkte berechnen und einzeichnen

Das Ziel dieses Abschnittes ist es in einem Graphen alle relevanten Punkte automatisch einzuzeichnen, so dass idealerweise der Nutzer nur seine Funktion eingeben muss und der Rest automatisch vom Programm gemacht wird.  
Das heißt vor allem auch, dass Nullstellen, Extrempunkte/ Sattelpunkte und Wendepunkte und der y-Achsenabschnitt eingezeichnet werden sollen.  

::: {.callout-note title="Hinweis Schritt 2" collapse="true"}
**Hinweis**, bei allen Teilen des Schritt 2 gilt, es kann ein relevanter x-Wert berechnet werden und dann mit $f(x_{relevanter Wert})$ der y-Wert bestimmt werden. Alle relevanten Punkte einer Gattung können in die gleiche Variablen Liste reingeschrieben werden und geplottet werden, so dass in deren Label und der Legende auch der passende Begriff angegeben wird.   
Z.B. sollten $x_{nullstelle} ={x_1,...,x_n} \quad \text{und} \quad y_{nullstelle} ={f(x_1),...,f(x_n)}$ derart sein, dass $\forall \quad x_i \in x_{nullstelle}$ gilt $f(x_i)=0$.  

_Bei allen Programmen soll $f(x)= x^3 - 6*x^2 + 9*x$ nur als Beispiel fungieren, natürlich sollten die Programme möglichst für alle Funktionen, oder mindestens sehr viele unterschiedliche Funktionen funktionieren._
:::

### Nullstellen

Zuerst solltest Du, auch wenn Du es bereits gesehen hast den Abschnitt [Nullstellen bestimmen](nullstellen.qmd) betrachten.  
Im Prinzip kannst Du den Code von dort mit dem Code von hier kombinieren.  
D.h. im folgenden Block sollst Du versuchen zusammen mit Deinem Wissen aus [Graphen](graphen.qmd) ein Programm zu schreiben, welches Die Nullstellen von $f(x)= x^3 - 6*x^2 + 9*x$ zum einen berechnet, aber auch in einem Plot markiert.  
Wenn es Dir einfacher fällt kannst Du dafür auch erstmal nicht die Funktion plotten, Ziel sollte jedoch sein die Funktion und den Nullstellen Plot in ein Programm zu integrieren, am besten so, dass beides in der Legende erscheint.

```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Tipp: Nullstellen" collapse="true"}
Der wichtige Befehl des [Nullstellen bestimmen](nullstellen.qmd) Abschnittes war:  
*  `sympy.solveset(f, x, domain=sympy.S.Reals)` damit ließen sich die Nullstellen von f bzgl. der Variable x bestimmen und es werden nur Lösungen angegeben, welche in der Domäne der Reellen Zahlen liegen.
:::

### Extrempunkte/ Sattelpunkte

Bevor Du das bearbeitest, solltest Du den Abschnitt [Extrempunkte](extrempunkte.qmd) anschauen.  
Hier sollst Du nämlich den Inhalt von dem Abschnitt zusammen mit dem Inhalt des [Graphen](graphen.qmd) verarbeiten mit dem Ziel ein Programm zu entwickeln, welches die Extremstellen von $f(x)= x^3 - 6*x^2 + 9*x$ bestimmt und diese auch im Graphen als solche einzeichnet.  

_Optimal wäre natürlich, wenn Tiefpunkte und Hochpunkte jeweils als solche ausgezeichnet werden würden._

```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Tipp: Extrempunkte/Sattelpunkte" collapse="true"}
Die wichtigen Funktionen aus dem [Extrempunkte](extrempunkte.qmd) Abschnitt waren:  
*   `sympy.diff(f,x)` diese Funktion bestimmt die Ableitung von f bezüglich der Variable x.
*   `sympy.solveset(f, x, domain=sympy.S.Reals)` damit können die Nullstellen einer Funktion bestimmt werden.

:::

### Wendepunkte

Bevor Du diesen Abschnitt bearbeitest sei geraten den Abschnitt [Wendepunkte](wendepunkte.qmd) anschauen, da es hier darum geht ein Programm zu erstellen, welches mithilfe des [Graphen](graphen.qmd) Wissens in der Lage ist die Wendepunkte von der Funktion $f(x)= x^3 - 6*x^2 + 9*x$ zu berechnen und diese in einem Plot einzuzeichnen, so dass diese auch in der Legende erscheinen.
```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Tipp: Wendepunkte" collapse="true"}
Die wichtigen Funktionen aus dem [Wendepunkte](wendepunkte.qmd) Abschnitt waren:    
*   `sympy.diff(f,x)` diese Funktion bestimmt die Ableitung von f bezüglich der Variable x.
*   `sympy.solveset(f, x, domain=sympy.S.Reals)` damit können die Nullstellen einer Funktion bestimmt werden.

:::

### Y-Achsenabschnitt

Beim Bearbeiten dieses Teils wird dir Vorwissen aus dem Abschnitt [Achsenschnittpunkte](achsenschnittpunkte.qmd) immens weiterhelfen.  
Mithilfe des Abschnittes [Graphen](graphen.qmd) ist deine Aufgabe einen Code zu schreiben welcher in der Lage ist den Achsenschnittpunkt der Funktion $f(x)= x^3 - 6*x^2 + 9*x $ zu bestimmen und passend in dem Plot zu markieren.

```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Tipp: Wendepunkte" collapse="true"}
Als Tipp kann hier gegeben werden, dass der Y-Achsenabschnitt einer jeden Funktion an der Stelle ist, an der $x=0$ ist, heißt $f(0)=y-Achsenabschnitt$.  

:::

### Kombination aus allem bisherigen.

Versuche nun alles bisherige in einem einzelnen Code unterzubringen, denk dran der Übersicht und der Funktion des Programmes halber jeweils eigen indizierte Variablen zu nutzen, welche zum Zweck passen.  

_In deinem Code solle auch eine Ausgabe der Werte im Textformat, so wie in den Kapiteln zuvor stattfinden, somit hat der Anwender die Möglichkeit es einmal graphisch und als Liste die Informationen zu bekommen, einige Informationen wie später die Monotonieintervalle sind auch ein wenig trickreich einzuzeichnen._

```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Eine möglichst simple mögliche Lösung" collapse="true"}

_Deine Lösung sollte idealerweise schöner aussehen als diese hier, aber falls du gar nicht weiter weißt kannst du dir hier gerne Ideen holen._  

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import sympy

# --- 1. Definitionen ---
x = sympy.symbols('x')
funktion_str = "x**3 - 6*x**2 + 9*x"
f_sym = sympy.sympify(funktion_str)

# --- 2. Berechnungen der besonderen Punkte ---
# Ableitungen
f_prime = sympy.diff(f_sym, x)
f_double_prime = sympy.diff(f_prime, x)

# Nullstellen
nullstellen_x = [float(ns) for ns in sympy.solveset(f_sym, x, domain=sympy.S.Reals)]
nullstellen_y = [0.0] * len(nullstellen_x) # y ist für Nullstellen immer 0

# Extrempunkte
extrema_x = [float(ex) for ex in sympy.solveset(f_prime, x, domain=sympy.S.Reals)]
extrema_y = [float(f_sym.subs(x, ex)) for ex in extrema_x]

# Wendepunkte
wendepunkte_x = [float(wx) for wx in sympy.solveset(f_double_prime, x, domain=sympy.S.Reals)]
wendepunkte_y = [float(f_sym.subs(x, wx)) for wx in wendepunkte_x]

# Y-Achsenabschnitt
y-achsenabschnitt_x = [0.0]
y-achsenabschnitt_y = [float(f_sym.subs(x, 0))]

# --- 3. Plotten ---
# Funktionsgraph
x_min, x_max = -5, 5
x_vals = np.linspace(x_min, x_max, 400)
f_np = sympy.lambdify(x, f_sym, 'numpy') 
y_vals = f_np(x_vals)

plt.plot(x_vals, y_vals, label=f'f(x) = {f_sym}')

# Besondere Punkte einzeichnen
plt.scatter(nullstellen_x, nullstellen_y, color='red', label='Nullstellen')
plt.scatter(extrema_x, extrema_y, color='green', label='Extrempunkte')
plt.scatter(wendepunkte_x, wendepunkte_y, color='purple', label='Wendepunkte')
plt.scatter(y-achsenabschnitt_x, y-achsenabschnitt_y, color='blue', label='Y-Achsenabschnitt')

# --- 4. Layout ---
plt.title('Simple Lösung')
plt.xlabel('x-Achse')
plt.ylabel('y-Achse')
plt.grid(True)
plt.legend()
plt.show()
```

:::

---

## Schritt 3: Asymptoten einzeichnen

Wie im Abschnitt [Asymptoten](asymptoten.qmd), bzw. [Globalverhalten](globalverhalten.qmd) bereits geklärt haben einige Funktionen Asymptoten, für diesen Teil des Tutorials sollte sich daher diese Abschnitte unbedingt angeschaut werden.

::: {.callout-note title="Erinnerung: Asymptoten finden" collapse="true"}
*   **Vertikale Asymptoten:** Nennernullstellen, die keine Zählernullstellen sind. (`sympy.fraction`, `sympy.solve`)
*   **Horizontale Asymptoten:** Grenzwert von `f(x)` für `x -> oo` und `x -> -oo`. (`sympy.limit`)
*   **Schiefe Asymptoten:** Ergebnis der Polynomdivision, wenn Zählergrad = Nennergrad + 1. (`sympy.div`)
:::

### Asymptoten berechnen und darstellen

Da die oben als Test benutzte Funktion keine Asymptoten hat denen sie sich annähert wird hier die Funktion $g(x) = \frac{2x^2 - 1}{x^2 - 4}$ betrachtet.  
Deine Aufgabe ist jetzt ein Programm zu schreiben, welches die folgenden Schritte ausführt:

1.  **Berechne** die vertikalen und horizontalen Asymptoten.
2.  **Zeichne** die Asymptoten ein _nutze gestrichelte Linien o.ä. um sie zu differenzieren_
3.  **Bonus:** Sorge dafür, dass der Graph an den vertikalen Asymptoten eine Lücke aufweist und keine verbindende Linie gezeichnet wird.
 
```{pyodide-python}
#Füge hier Deinen Code ein.
x = sympy.symbols('x')
f= (2*x**2 - 1) / (x**2 - 4)
```

::: {.callout-note title="Tipp: Asymptote" collapse="true"}
Vielleicht bist Du Dir des Problems schon gewahr geworden und guckst daher in die Tipps, ansonsten versuche Dich doch ein wenig an dem Programm bevor du hier reinliest.

<details>
<summary> Tipps für das Plotten von Asymptoten </summary>

Es nicht trivial die Asymptoten einzuzeichnen und gibt mehrere Möglichkeiten  

1.  Die Asymptoten Funktion berechnen und dann als Funktion plotten.
2.  Horizontale/Vertikale Linien einzeichnen mit `plt.axhline()` und `plt.axvline()` an den richtigen Stellen. 

Warum sollte man 2. machen? Es gibt leider vor allem bei der vertikalen Asymptote ein Problem mit dem plotting per `matplotlib`, $x=a$ kann nicht so ohne weiteres geplottet werden, eine vertikale Linie (`plt.axvline()`) lässt jedoch recht leicht plotten.  

Bei der schiefen Asymptote lässt sich nun aber 2. nicht anwenden, da hier keine horizontale/vertikale Linie gesucht wird, sondern entweder eine schiefe Gerade oder eine Kurve, bei beiden Möglichkeiten hilft nur die Asymptoten Funktion tatsächlich zu plotten.

</details>

<details>
<summary> Tipp für eine saubere grafische Darstellung </summary>

Du wirst feststellen, dass `matplotlib` versucht, eine durchgehende Linie zu zeichnen, auch über die vertikale Asymptote hinweg. Das sieht nicht schön aus.

Um das zu verhindern, kannst du einen Trick anwenden:
*   Finde die x-Werte, die sehr nah an deiner Asymptote liegen. (Nahe der bestimmten Nullstelle des Nenners)
*   Ersetze die zugehörigen y-Werte an diesen Stellen durch `np.nan` (Not a Number).
*   `matplotlib` zeichnet dann automatisch eine Lücke im Graphen.

Ein Code-Schnipsel dazu könnte so aussehen:
```{pyodide-python}
y_vals[np.abs(x_vals - asymptote_x_wert) < 0.1] = np.nan
```

_Der Code sorgt dafür, dass die Y-Werte in einem Betragsabstand von 0,1 um den x Wert an dem eine Definitionslücke existiert nicht gezeichnet werden._

</details>

:::

# Abschlussprojekt: Dein eigenes Analyse-Tool

Zielgerade! Du hast dir in diesem Tutorial jetzt alle Fähigkeiten erarbeitet, die Du benötigst um Dir im folgenden ein einzelnes Python Programm zu schreiben, welches eine komplette Kurvendiskussion (wie sie meist in der Schule durchgeführt wird) durchzuführen.

## Erstelle Dein Analyse-Tool

Nun geht's an dir Arbeit!  
Wichtig ist, dass Du Dir einen Überblick machst davon, was du alles in dem Programm bearbeiten willst, und dir die Kapitel die Du dafür benötigst nebenbei vielleicht in einem anderen Tab aufmachst.  

Wichtig ist, du solltest Dir überlegen, welche Bereiche du mit in den Graphen einzeichnen kannst. Dennoch solltest du einmal alle Angaben zur Funktion auch Schriftlich ausgeben lassen, die Werte sind so oder so berechnet.  

```{pyodide-python}
#Füge Dein Analyse-Tool hier ein.
```

::: {.callout-note title="Dein Analyse Tool: Tipp 1" collapse="true"}
Wenn es darum geht einen großen Code zu  erstellen sollte zur eigenen Übersicht, aber auch der Übersicht anderer der Code systematisiert werden.  

In diesem Fall heißt das also z.B.:  

1.  **Import der relevanten Bibliotheken**
2.  **Definition der Variablen/der Objekte oder noch besser der `function`**
     * Functions sind in diesem Tutorial schon erschienen, dennoch eine kurze Zusammenfassung. Eine der elegantesten Lösungen wäre, das Programm als eine function zu schreiben, so dass unten an den Python Code angefügt werden kann function($x^2+3x-7$) und dann eine Kurvendiskussion von $x^2+3x-7$ durchgeführt wird.   
3.  **Berechnung der relevanten Werte**
     * Hierbei kann gerne auch jeder der Werte differenziert werden, also über einer Gruppe von Rechnungen steht #Wendepunkte z.B.
     * x_Wendepunkte, y_Wendepunkte hilft auch enorm dabei eine Übersicht zu haben, also die passenden Wertepaare in ihrer Definition mit ihrem Ursprung benennen
4.  **Plotten der relevanten Werte**
     * Hier gilt das gleiche wie oben (beides hilft stark bei der Fehlerbehebung)
5.  **Eigenschaften des Graphen bestimmen**
     * Legende
     * Grid
     * Achsenbeschriftung
     * Titel des Graphen etc.

<details>
<summary> Klicke HIER, um eine mögliche `function`, die die Fakultät einer beliebigen Zahl bestimmt zu sehen: </summary>

```{pyodide-python}
def fakultaet_berechnen(n):
    # Prüfen, ob die Eingabe eine gültige Zahl ist
    if not isinstance(n, int) or n < 0:
        return "Fehler: Bitte eine nicht-negative ganze Zahl eingeben."
    
    # Basisfall: Die Fakultät von 0 ist 1
    if n == 0:
        return 1
    
    # Berechnung der Fakultät
    ergebnis = 1
    for i in range(1, n + 1):
        ergebnis = ergebnis * i
        
    return ergebnis

# Beispielaufruf der Funktion
zahl = 5
print(f"Die Fakultät von {zahl} ist: {fakultaet_berechnen(zahl)}")
```

</details>


:::

::: {.callout-note title="Dein Analyse Tool: Tipp 2" collapse="true"}
Ein gutes Programm zeichnet sich durch Details und Robustheit aus. Hier sind einige Ideen, wie du dein Tool noch besser machen kannst:

*   **Unterscheide zwischen Hoch- und Tiefpunkten:**
    *   Anstatt alle Extrema in eine Liste zu packen, durchlaufe die gefundenen x-Werte der Extrema in einer Schleife die die Bedingungen überprüft.
    *   Sortiere die Punkte in separate Listen (z.B. `x_hochpunkte`,  `x_tiefpunkte`,  `y_tiefpunkte`, `x_sattelpunkte`, `y_sattelpunkte`) und plotte sie mit unterschiedlichen Farben oder Markern _Um sie deutlich zu unterscheiden_

*   **Umgang mit möglichen Fehlern:**
    *   Dein Code sollte idealerweise eine Ausgabe haben, welche einen Fehler ausgibt, wenn die Funktion von deinem Programm nicht bearbeitet werden kann:

<details>

<summary> Ein Beispiel </summary>

```{pyodide-python}
import sympy

funktion_str = "log(x / (x-1" # Ungültig, da eine Klammer fehlt

try:
    x = sympy.symbols('x')
    f_sym = sympy.sympify(funktion_str)
    print(f"Funktion erfolgreich erstellt: {f_sym}")
except sympy.SympifyError as e:
    print(f"Die Funktion konnte nicht erstellt werden, Fehler war: {e}")
```

</details>

*   **Saubere Textausgabe:**
    *   Es hilft beim erstellen eines eigenen Codes eine Menge die berechneten Werte ausgeben zulassen, dadurch fällt Dir schneller auf wo der Fehler liegen könnte.
:::

::: {.callout-note title="Dein Analyse Tool: Tipp 3" collapse="true"}
Zielgerade! Die Grundfunktion steht vermutlich bereits, hier sind noch ein paar Tipps, um Dein Programm abzurunden.

*   **Vollständige Text-Analyse:**
    *   Ein Graph ist toll, aber für eine vollständige Kurvendiskussion braucht man auch Text. Plotte nicht nur die Punkte, sondern auch die **Intervalle** für Monotonie und Krümmung.
    *   Vergiss nicht, auch den **Definitions- und Wertebereich** auszugeben! 
*   **Dynamischer und intelligenter Plot-Bereich:**
    *   Anstatt feste `x_min` und `x_max` Werte zu verwenden, passe den Plot-Bereich dynamisch an die Funktion an!
    *   **Idee:** Sammle alle relevanten x-Werte (Nullstellen, Extrema, Wendepunkte). Finde den kleinsten und größten dieser Werte und füge auf beiden Seiten einen kleinen Puffer hinzu (z.B. 20 % des Gesamtbereichs). So stellst du sicher, dass alle wichtigen Merkmale immer gut sichtbar sind, egal welche Funktion analysiert wird.

<details>
<summary> Ein Beispiel für einen Code der den X-Bereich dynamisch bestimmt </summary>

```{pyodide-python}
# Angenommen, du hast diese Listen mit x-Werten:
nullstellen_x = [0, 3]
extrema_x = [1, 3]
wendepunkte_x = [2]

# Sammle alle x-Werte in einer Liste
alle_x_punkte = nullstellen_x + extrema_x + wendepunkte_x

if alle_x_punkte:
    # Finde min/max und berechne Puffer
    x_min_auto = min(alle_x_punkte)
    x_max_auto = max(alle_x_punkte)
    puffer = (x_max_auto - x_min_auto) * 0.2 # 20% Puffer
    
    # Setze finale Plot-Grenzen
    x_plot_min = x_min_auto - puffer
    x_plot_max = x_max_auto + puffer
else:
    # Fallback, falls keine Punkte gefunden wurden
    x_plot_min = -5
    x_plot_max = 5

print(f"Automatischer Plot-Bereich von {x_plot_min:.2f} bis {x_plot_max:.2f}")

# Diese Werte kannst du dann für np.linspace(x_plot_min, x_plot_max, 400) verwenden.
```

</details>

:::

GRATULATIONEN, wenn du hier angekommen bist, hast du das gesamte Tutorial durchgearbeitet, jetzt solltest du:  
1.  Eine kleine Erinnerung an die Schulmathematik gehabt haben
2.  Die Grundmechaniken von Python verstanden haben
3.  In der Lage sein eine Kurvendiskussion in Python durchzuführen
4.  Auch andere Probleme in Python lösen können indem du die Systeme die du hier kennen gelernt hast dort da anwendest!

Wenn du nicht mal alle Tipps aufmachen musstest, oder beim öffnen des ein oder anderen Tipps dachtest, "Ach das habe ich doch schon..." dann kannst du Dir getrost auf die Schulter klopfen, dass hast du außerordentlich gut gemacht!