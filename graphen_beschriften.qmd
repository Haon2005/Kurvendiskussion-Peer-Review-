---
title: "Graphen beschriften"
filters:
  - pyodide
  - quizdown
---

# Graphen beschriften

Willkommen zum **Abschlusskapitel!**  
Hier wird alles aus den vorherigen Abschnitten zusammengefasst und verarbeitet. Unser Ziel ist es, ein einziges, leistungsfähiges Python-Programm zu entwickeln, das eine Funktion umfassend analysiert und alle wichtigen Merkmale – Achsenschnittpunkte, Extrema, Wendepunkte und Asymptoten – in einem einzigen, übersichtlichen Graphen darstellt.

---

## Schritt 1: Das Grundgerüst – Eine Funktion plotten

Alles beginnt mit der Fähigkeit, eine Funktion grafisch darzustellen. Hier kann das Wissen aus dem Abschnitt [Graphen erstellen](graphen.qmd) helfen, um eine Basis zu schaffen.

::: {.callout-note title="Erinnerung: Graphen erstellen" collapse="true"}
Im Abschnitt [Graphen erstellen](graphen.qmd) haben wir gelernt, wie man eine Funktion mit `numpy` und `matplotlib` plottet. Der grundlegende Ablauf war:

1.  Variablen/Funktion mit `sympy` definieren.
3.  Mit `numpy.linspace` eine Reihe von x-Werten erzeugen.
4.  Die y-Werte berechnen.
5.  Mit `matplotlib.pyplot.plot` den Graphen zeichnen.
:::

---

### Plotten der Basisfunktion

Ein kleiner Startcode von dem aus du den Rest des Kapitels erarbeiten sollst (mit Tipps natürlich!).

<details>
<summary> Hier klicken, um den Startcode anzuzeigen! </summary>

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import sympy
x = sympy.symbols('x')
f = x**3 - 6*x**2 + 9*x

f_str="x**3 - 6*x**2 + 9*x"
f_sym = sympy.sympify(f_str) #simpify macht aus einem String eine sympy Funktion
f_np = sympy.lambdify(x, f_sym, 'numpy')#lambdify macht aus einer sympy Funktion eine numpy Funktion (damit können Rechnungen deutlich schneller durchgeführt werden)

x_vals = np.linspace(-1, 5, 400)
y_vals = f_np(x_vals)
plt.plot(x_vals, y_vals)
plt.title('Basisfunktion')
plt.xlabel('x-Achse')
plt.ylabel('y-Achse')
plt.grid(True)
plt.show()
```

</details>

::: {.callout-note title="Hinweis zu unterschiedlichen Objektformen in Python" collapse="true"}
Im obigen Code sind alle in diesem Tutorial vorgekommenen Varianten eine Funktion in Python einzuspeisen, noch einmal aufgeführt.  
Ein Überblick, was die unterschiedlichen Objekte für Vor-/Nachteile haben.  

*   `String-Objekt:` Ein String ist eine Aneinanderreihung von Zeichen. Das heißt wenn die Funktion angegeben wird, ist sie wie ein beliebiges Wort für Python. 
     * Dies ist vor allem (**was leider in diesem Tutorial nicht gemacht werden kann**) wichtig, wenn es darum geht eine Eingabe des Nutzers außerhalb des Codes abzufragen. Das heißt, wenn ich will, dass die Nutzenden vom Programm die Frage gestellt bekommen "Welche Funktion willst du untersuchen?" 
     * Die Nutzenden könnten dann die zu untersuchende Funktion in den Terminal eingeben, diese würde als String von Python ausgelesen und nach dem Durchlauf des Programms würden alle relevanten Eigenschaften der Funktion angezeigt. (**Funktioniert nicht in der Web-Umgebung**)
*   `Sympy-Objekt:` Mit einer Funktion die so in Python gespeichert ist kann algebraisch gearbeitet werden, heißt damit können Nullstellen berechnet, Ableitungen bestimmt werden können.
*   `Numpy-Objekt:`  Mit einer so gespeicherten Funktion kann sehr gut gerechnet werden, hier wird die Funktion in effektiver Vektorschreibweise gespeichert damit Rechnungen möglichst effektiv durchgeführt werden können.

```{pyodide-python}
x = sympy.symbols('x') 
f = x**3 - 6*x**2 + 9*x
```

Diese Variante wurde häufig im Tutorial genutzt, $f$ ist hierbei ein `Sympy-Objekt`, da in der Variable $f$ eine Variable vorkommt, die vorher explizit als `Sympy-Variable` definiert wird.  

```{pyodide-python}
f_str="x**3 - 6*x**2 + 9*x"
```

In diesem Fall ist f_str eine Funktion, die als `String-Objekt` gespeichert ist.
```{pyodide-python}
f_str="x**3 - 6*x**2 + 9*x"
f_sym = sympy.sympify(f_str) 
```

Durch `sympy.sympify` wird aus dem String ein `Sympy-Objekt` (identisch mit dem ersten Beispiel) erstellt.
```{pyodide-python}
f_np = sympy.lambdify(x, f_sym, 'numpy')  
```

`sympy.lambdify` ist eine Art Übersetzer mit dem Objekte in einen anderen Objekttypen verwandelt werden, in diesem Fall wird $f_{sym}$ basierend auf der Variable $x$ in `numpy` übersetzt, das heißt $f_{np}$ ist ein `Numpy-Objekt`.

:::

---

## Schritt 2: Besondere Punkte berechnen und einzeichnen

Das Ziel dieses Abschnittes ist es, in einem Graphen alle relevanten Punkte automatisch einzuzeichnen, so dass idealerweise die Nutzenden nur die Funktion eingeben müssen und der Rest automatisch vom Programm gemacht wird.  
Das heißt vor allem auch, dass Nullstellen, Extrempunkte/Sattelpunkte und Wendepunkte und der y-Achsenabschnitt eingezeichnet werden sollen.  

::: {.callout-note title="Hinweis Schritt 2" collapse="true"}
**Hinweis**, bei allen Teilen des Schritt 2 gilt. Es kann ein relevanter x-Wert berechnet werden und dann mit $f(x_{relevanter Wert})$ der y-Wert bestimmt werden. Alle relevanten Punkte einer Gattung können in die gleiche Variablenliste reingeschrieben werden und geplottet werden, so dass in deren Label und der Legende auch der passende Begriff angegeben wird.   
Z.B. sollten $x_{nullstelle} ={x_1,...,x_n} \quad \text{und} \quad y_{nullstelle} ={f(x_1),...,f(x_n)}$ derart sein, dass $\forall \quad x_i \in x_{nullstelle}$ gilt $f(x_i)=0$.  

_Bei allen Programmen soll $f(x)= x^3 - 6*x^2 + 9*x$ nur als Beispiel fungieren, natürlich sollten die Programme möglichst für alle Funktionen, oder mindestens sehr viele unterschiedliche Funktionen funktionieren._
:::

### Nullstellen

Zuerst solltest du, auch wenn du es bereits gesehen hast den Abschnitt [Nullstellen bestimmen](nullstellen.qmd) betrachten.  
Im Prinzip kannst du den Code von dort mit dem Code von hier kombinieren.  
Das heißt im folgenden Block sollst du versuchen zusammen mit deinem Wissen aus [Graphen](graphen.qmd) ein Programm zu schreiben, welches die Nullstellen von $f(x)= x^3 - 6*x^2 + 9*x$ zum einen berechnet, aber auch in einem Plot markiert.  
Wenn es dir einfacher fällt, kannst du dafür auch erstmal nicht die Funktion plotten, Ziel sollte jedoch sein, die Funktion und den Nullstellen-Plot in ein Programm zu integrieren, am besten so, dass beides in der Legende erscheint.

```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Tipp: Nullstellen" collapse="true"}
Der wichtige Befehl des [Nullstellen bestimmen](nullstellen.qmd) Abschnittes war:  
*  `sympy.solveset(f, x, domain=sympy.S.Reals)` damit ließen sich die Nullstellen von f bzgl. der Variable x bestimmen und es werden nur Lösungen angegeben, welche in der Domäne der reellen Zahlen liegen.
:::

### Extrempunkte/ Sattelpunkte

Bevor du das bearbeitest, solltest du den Abschnitt [Extrempunkte](extrempunkte.qmd) anschauen.  
Hier sollst du nämlich den Inhalt von dem Abschnitt zusammen mit dem Inhalt des [Graphen](graphen.qmd) verarbeiten mit dem Ziel, ein Programm zu entwickeln, welches die Extremstellen von $f(x)= x^3 - 6*x^2 + 9*x$ bestimmt und diese auch im Graphen als solche einzeichnet.  

_Optimal wäre natürlich, wenn Tiefpunkte und Hochpunkte jeweils als solche ausgezeichnet werden würden._

```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Tipp: Extrempunkte/Sattelpunkte" collapse="true"}
Die wichtigen Funktionen aus dem [Extrempunkte](extrempunkte.qmd) Abschnitt waren:  
*   `sympy.diff(f,x)` diese Funktion bestimmt die Ableitung von f bezüglich der Variable x.
*   `sympy.solveset(f, x, domain=sympy.S.Reals)` damit können die Nullstellen einer Funktion bestimmt werden.

:::

### Wendepunkte

Bevor Du diesen Abschnitt bearbeitest sei geraten, den Abschnitt [Wendepunkte](wendepunkte.qmd) anschauen, da es hier darum geht ein Programm zu erstellen, welches mithilfe des [Graphen](graphen.qmd) Wissens in der Lage ist die Wendepunkte von der Funktion $f(x)= x^3 - 6*x^2 + 9*x$ zu berechnen und diese in einem Plot einzuzeichnen, sodass diese auch in der Legende erscheinen.
```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Tipp: Wendepunkte" collapse="true"}
Die wichtigen Funktionen aus dem [Wendepunkte](wendepunkte.qmd) Abschnitt waren:    
*   `sympy.diff(f,x)` diese Funktion bestimmt die Ableitung von f bezüglich der Variable x.
*   `sympy.solveset(f, x, domain=sympy.S.Reals)` damit können die Nullstellen einer Funktion bestimmt werden.

:::

### Y-Achsenabschnitt

Beim Bearbeiten dieses Teils wird dir Vorwissen aus dem Abschnitt [Achsenschnittpunkte](achsenschnittpunkte.qmd) immens weiterhelfen.  
Mithilfe des Abschnittes [Graphen](graphen.qmd) ist deine Aufgabe einen Code zu schreiben, welcher in der Lage ist den Achsenschnittpunkt der Funktion $f(x)= x^3 - 6*x^2 + 9*x $ zu bestimmen und passend in dem Plot zu markieren.

```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Tipp: Y-Achsenabschnitt" collapse="true"}
Als Tipp kann hier gegeben werden, dass der Y-Achsenabschnitt einer jeden Funktion an der Stelle ist, an der $x=0$ ist, heißt $f(0)=y-Achsenabschnitt$.  

:::

### Kombination aus allem bisherigen.

Versuche nun alles bisherige in einem einzelnen Code unterzubringen, denk dran der Übersicht und der Funktion des Programms halber jeweils eigens indizierte Variablen zu nutzen, welche zum Zweck passen.  

_In deinem Code sollte auch eine Ausgabe der Werte im Textformat, so wie in den Kapiteln zuvor stattfinden, somit haben Nutzende die Möglichkeit es einmal graphisch und als Liste der Informationen zu bekommen, einige Informationen wie später die Monotonieintervalle sind auch ein wenig trickreich einzuzeichnen._

```{pyodide-python}
#Füge hier Deinen Code ein.
```

::: {.callout-note title="Eine möglichst simple mögliche Lösung" collapse="true"}

_Deine Lösung sollte idealerweise schöner aussehen als diese hier, aber falls du gar nicht weiter weißt kannst du dir hier gerne Ideen holen._  

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
import sympy

# --- 1. Definitionen ---
x = sympy.symbols('x')
funktion_str = "x**3 - 6*x**2 + 9*x"
f_sym = sympy.sympify(funktion_str)

# --- 2. Berechnungen der besonderen Punkte ---
# Ableitungen
f_prime = sympy.diff(f_sym, x)
f_double_prime = sympy.diff(f_prime, x)

# Nullstellen
nullstellen_x = [float(ns) for ns in sympy.solveset(f_sym, x, domain=sympy.S.Reals)]
nullstellen_y = [0.0] * len(nullstellen_x) # y ist für Nullstellen immer 0

# Extrempunkte
extrema_x = [float(ex) for ex in sympy.solveset(f_prime, x, domain=sympy.S.Reals)]
extrema_y = [float(f_sym.subs(x, ex)) for ex in extrema_x]

# Wendepunkte
wendepunkte_x = [float(wx) for wx in sympy.solveset(f_double_prime, x, domain=sympy.S.Reals)]
wendepunkte_y = [float(f_sym.subs(x, wx)) for wx in wendepunkte_x]

# Y-Achsenabschnitt
y_achsenabschnitt_x = [0.0]
y_achsenabschnitt_y = [float(f_sym.subs(x, 0))]

# --- 3. Plotten ---
# Funktionsgraph
x_min, x_max = -5, 5
x_vals = np.linspace(x_min, x_max, 400)
f_np = sympy.lambdify(x, f_sym, 'numpy') 
y_vals = f_np(x_vals)

plt.plot(x_vals, y_vals, label=f'f(x) = {f_sym}')

# Besondere Punkte einzeichnen
plt.scatter(nullstellen_x, nullstellen_y, color='red', label='Nullstellen')
plt.scatter(extrema_x, extrema_y, color='green', label='Extrempunkte')
plt.scatter(wendepunkte_x, wendepunkte_y, color='purple', label='Wendepunkte')
plt.scatter(y_achsenabschnitt_x, y_achsenabschnitt_y, color='blue', label='Y-Achsenabschnitt')

# --- 4. Layout ---
plt.title('Simple Lösung')
plt.xlabel('x-Achse')
plt.ylabel('y-Achse')
plt.grid(True)
plt.legend()
plt.show()
```

:::

---

## Schritt 3: Asymptoten einzeichnen

Wie im Abschnitt [Asymptoten](asymptoten.qmd), bzw. [Globalverhalten](globalverhalten.qmd) bereits geklärt, haben einige Funktionen Asymptoten, für diesen Teil des Tutorials solltest du dir daher diese Abschnitte unbedingt anschauen.

::: {.callout-note title="Erinnerung: Asymptoten finden" collapse="true"}
*   **Vertikale Asymptoten:** Nennernullstellen, die keine Zählernullstellen sind. (`sympy.fraction`, `sympy.solve`)
*   **Horizontale Asymptoten:** Grenzwert von `f(x)` für `x -> oo` und `x -> -oo`. (`sympy.limit`)
*   **Schiefe Asymptoten:** Ergebnis der Polynomdivision, wenn Zählergrad = Nennergrad + 1. (`sympy.div`)
:::

### Asymptoten berechnen und darstellen

Da die oben als Test benutzte Funktion keine Asymptoten hat, denen sie sich annähert wird hier die Funktion $g(x) = \frac{2x^2 - 1}{x^2 - 4}$ betrachtet.  
Deine Aufgabe ist jetzt ein Programm zu schreiben, welches die folgenden Schritte ausführt:

1.  **Berechne** die vertikalen und horizontalen Asymptoten.
2.  **Zeichne** die Asymptoten ein _nutze gestrichelte Linien o.ä. um sie zu unterscheiden_
3.  **Bonus:** Sorge dafür, dass der Graph an den vertikalen Asymptoten eine Lücke aufweist und keine verbindende Linie gezeichnet wird.
 
```{pyodide-python}
#Füge hier Deinen Code ein.
x = sympy.symbols('x')
f= (2*x**2 - 1) / (x**2 - 4)
```

::: {.callout-note title="Tipp: Asymptote" collapse="true"}
Vielleicht bist Du Dir des Problems schon gewahr geworden und guckst daher in die Tipps, ansonsten versuche Dich doch ein wenig an dem Programm bevor du hier reinliest.

<details>
<summary> Tipps für das Plotten von Asymptoten </summary>

Es ist nicht trivial die Asymptoten einzuzeichnen und gibt mehrere Möglichkeiten  

1.  Die Asymptotenfunktion berechnen und dann als Funktion plotten.
2.  Horizontale/Vertikale Linien einzeichnen mit `plt.axhline()` und `plt.axvline()` an den richtigen Stellen. 

Warum sollte man 2. machen? Es gibt leider vor allem bei der vertikalen Asymptote ein Problem mit dem plotting per `matplotlib`, $x=a$ kann nicht so ohne weiteres geplottet werden, eine vertikale Linie (`plt.axvline()`) lässt sich jedoch recht leicht plotten.  

Bei der schiefen Asymptote lässt sich nun aber 2. nicht anwenden, da hier keine horizontale/vertikale Linie gesucht wird, sondern entweder eine schiefe Gerade oder eine Kurve, bei beiden Möglichkeiten hilft nur die Asymptotenfunktion tatsächlich zu plotten.

</details>

<details>
<summary> Tipp für eine saubere grafische Darstellung </summary>

Du wirst feststellen, dass `matplotlib` versucht, eine durchgehende Linie zu zeichnen, auch über die vertikale Asymptote hinweg. Das sieht nicht schön aus.

Um das zu verhindern, kannst du einen Trick anwenden:
*   Finde die x-Werte, die sehr nah an deiner Asymptote liegen. (Nahe der bestimmten Nullstelle des Nenners)
*   Ersetze die zugehörigen y-Werte an diesen Stellen durch `np.nan` (Not a Number).
*   `matplotlib` zeichnet dann automatisch eine Lücke im Graphen.

Ein Code-Schnipsel dazu könnte so aussehen:
```{pyodide-python}
y_vals[np.abs(x_vals - asymptote_x_wert) < 0.1] = np.nan
```

_Der Code sorgt dafür, dass die Y-Werte in einem Betragsabstand von 0,1 um den x Wert an dem eine Definitionslücke existiert nicht gezeichnet werden._

</details>

:::

# Abschlussprojekt: Dein eigenes Analyse-Tool

Zielgerade! du hast dir in diesem Tutorial jetzt alle Fähigkeiten erarbeitet, die du benötigst um dir im Folgenden ein einzelnes Python-Programm zu schreiben, welches eine komplette Kurvendiskussion (wie sie meist in der Schule durchgeführt wird) durchführt.

## Ein Quiz über alles was du für dein Analyse-Tool brauchst

:::{.callout-tip collapse="true" title="Das Quiz ist hier hinter, damit es nicht die Übersicht stört."}
```quizdown
# Welche drei Bibliotheken sind das "Dream-Team" für unser Analyse-Projekt?
- [x] `sympy` 
- [x] `matplotlib.pyplot` 
- [x] `numpy` 
- [ ] `pandas` 
- [ ] `random` 

> Hinweis: Wir brauchen Symbolik, Numerik und Grafik.

# Warum müssen wir eine SymPy-Funktion mit `sympy.lambdify` umwandeln, bevor wir sie mit Matplotlib plotten?
1. [x] Weil Matplotlib nicht direkt mit symbolischen SymPy-Formeln rechnen kann. Wir brauchen eine Funktion, die NumPy-Arrays verarbeitet.
1. [ ] Weil die Funktion sonst falsch abgeleitet wird.
1. [ ] Weil der Code sonst zu langsam ist.

> Hinweis: Matplotlib braucht viele konkrete Zahlen (x und y), keine Buchstaben.

# Bringe den Workflow für das Erstellen eines Graphen in die richtige Reihenfolge.
1. f_numpy = sympy.lambdify(x, f, "numpy")
2. x_werte = np.linspace(-5, 5, 400)
3. y_werte = f_numpy(x_werte)
4. plt.plot(x_werte, y_werte)
5. plt.show()

> Hinweis: Erst umwandeln, dann x-Werte erzeugen, dann y-Werte berechnen, dann zeichnen.

# Mit welchem Befehl erzeugst du ein Array von 100 x-Werten zwischen -10 und 10?
1. [x] `np.linspace(-10, 10, 100)`
1. [ ] `np.range(-10, 10)`
1. [ ] `sympy.symbols(-10, 10)`
1. [ ] `plt.axis(-10, 10)`

# Du hast Extrempunkte berechnet. Welcher Befehl eignet sich am besten, um diese *einzelnen Punkte* im Graphen zu markieren?
1. [x] `plt.scatter(x_liste, y_liste)`
1. [ ] `plt.plot(x_liste, y_liste)`
1. [ ] `plt.bar(x_liste, y_liste)`

> Hinweis: `plot` verbindet Punkte mit Linien, wir wollen aber nur die Punkte (Streudiagramm).

# Welche Befehle helfen dir, den Graphen übersichtlicher zu gestalten?
- [x] `plt.grid()` 
- [x] `plt.title("Mein Graph")` 
- [x] `plt.xlabel("x")` und `plt.ylabel("f(x)")` 
- [ ] `plt.make_pretty()`
- [x] `plt.axhline(0, color='black')` 

> Hinweis: Denk darüber nach, was einen Graphen "übersichtlicher" macht, was sollte man leicht sehen können?

# Du möchtest an einen Hochpunkt $(2|4)$ den Text "HP" schreiben. Welcher Befehl macht das?
1. [x] `plt.annotate("HP", (2, 4))`
1. [ ] `plt.write("HP", 2, 4)`
1. [ ] `plt.print(2, 4, "HP")`

> Hinweis: Wir wollen eine Anmerkung (Annotation) an Koordinaten heften.

# Wie sorgst du dafür, dass deine geplotteten Linien eine Legende bekommen (z.B. "f(x)" und "f'(x)")?
1. [x] Ich nutze in `plt.plot(..., label="Name")` das Label-Argument und rufe am Ende `plt.legend()` auf.
1. [ ] Das macht Matplotlib automatisch.
1. [ ] Ich schreibe es mit `plt.text` daneben.

# Was passiert, wenn du `plt.show()` vergisst?
1. [x] Der Graph wird (je nach Umgebung) eventuell nicht angezeigt.
1. [ ] Der Graph wird gelöscht.
1. [ ] Es gibt eine Fehlermeldung.

> Hinweis: `show()` ist der Befehl: "Jetzt alles auf den Bildschirm malen!".

# Du willst eine senkrechte Asymptote (vertikale Linie) bei $x=2$ einzeichnen. Welcher Befehl passt?
1. [x] `plt.axvline(2, color='red', linestyle='--')`
1. [ ] `plt.axhline(2)`
1. [ ] `plt.plot(2)`

> Hinweis: "v" steht für vertical (senkrecht).

# Was berechnet `sympy.diff(f, x, 2)`?
1. [x] Die zweite Ableitung $f''(x)$.
1. [ ] Die erste Ableitung quadriert.
1. [ ] Das Integral.

# Welche mathematische Bedingung prüfst du im Code, um einen Wendepunkt zu bestätigen?
- [x] $f''(x_0) = 0$
- [x] `$f'''(x_0) \neq 0$`
- [ ] $f'(x_0) = 0$

> Hinweis: Die Krümmung muss Null sein und sich ändern.

# Wie beschränkst du die Ansicht der y-Achse auf den Bereich -10 bis 10 (Zoom)?
1. [x] `plt.ylim(-10, 10)`
1. [ ] `plt.range_y(-10, 10)`
1. [ ] `plt.zoom(-10, 10)`

# Du hast eine Liste mit x-Koordinaten von Hochpunkten: `hp_x = [-2, 2]`. Wie bekommst du die passenden y-Werte, um sie zu plotten?
1. [x] Ich setze jeden x-Wert in die Funktion ein (z.B. in einer Schleife oder mit `f_numpy(np.array(hp_x))`).
1. [ ] Die y-Werte sind immer 0.
1. [ ] Ich rate sie.

> Hinweis: Ein Punkt besteht immer aus $(x | f(x))$.

# Wenn du mehrere Kurven in ein Bild plotten willst (z.B. $f$ und $f'$), was musst du tun?
1. [x] Einfach mehrere `plt.plot(...)`-Befehle nacheinander aufrufen, bevor `plt.show()` kommt.
1. [ ] Für jede Kurve ein neues Skript schreiben.
1. [ ] `plt.multi_plot()` nutzen.

# Was ist der Vorteil von `f-Strings` (z.B. `f"HP bei {x}"`) beim Beschriften?
1. [x] Man kann Variablenwerte (wie berechnete Koordinaten) direkt in den Text einbauen.
1. [ ] Sie sind schneller zu tippen.
1. [ ] Sie machen den Text fett.

# Welche Farbe wird in Matplotlib mit dem Kürzel `'k'` erzeugt?
1. [x] Schwarz (Black - 'b' ist schon für Blue vergeben).
1. [ ] Kunterbunt.
1. [ ] Kupfer.

# Bringe die Schritte zum Einzeichnen von Nullstellen in die richtige Reihenfolge.
1. nullstellen = sympy.solve(f, x)
2. # Umwandeln der SymPy-Zahlen in float (für Matplotlib)
3. for ns in nullstellen:
4.     y_coord = 0
5.     plt.scatter(ns, y_coord, color='red')

# Was bedeutet `linestyle='--'` im Plot-Befehl?
1. [x] Die Linie wird gestrichelt gezeichnet.
1. [ ] Die Linie wird besonders dünn.
1. [ ] Die Linie wird doppelt gezeichnet.

# Dein Code wirft einen Fehler: `NameError: name 'np' is not defined`. Was hast du vergessen?
1. [x] `import numpy as np`
1. [ ] `import number_python`
1. [ ] NumPy zu installieren.

> Hinweis: Man muss dem Kind einen Namen geben (Alias), wenn man es so rufen will.
```
:::

## Erstelle Dein Analyse-Tool

Nun geht's an die Arbeit!  
Wichtig ist, dass du dir einen Überblick verschaffst darüber, was du alles in dem Programm bearbeiten willst, und dir die Kapitel die du dafür benötigst nebenbei vielleicht in einem anderen Tab aufmachst.  

Wichtig ist, du solltest dir überlegen, welche Bereiche du mit in den Graphen einzeichnen kannst. Dennoch solltest du einmal alle Angaben zur Funktion auch schriftlich ausgeben lassen, die Werte sind so oder so berechnet.  

```{pyodide-python}
#Füge Dein Analyse-Tool hier ein.
```

::: {.callout-note title="Dein Analyse Tool: Tipp 1" collapse="true"}
Wenn es darum geht einen großen Code zu erstellen, sollte zur eigenen Übersicht, aber auch der Übersicht anderer der Code systematisiert werden.  

In diesem Fall heißt das also z.B.:  

1.  **Import der relevanten Bibliotheken**
2.  **Definition der Variablen/der Objekte oder noch besser der `function`**
     * Funktionen (`functions`) sind in diesem Tutorial schon erschienen, dennoch eine kurze Zusammenfassung. Eine der elegantesten Lösungen wäre, das Programm als eine Funktion zu schreiben, so dass unten an den Python Code angefügt werden kann `function("x^2+3x-7")` und dann eine Kurvendiskussion von $x^2+3x-7$ durchgeführt wird.   
3.  **Berechnung der relevanten Werte**
     * Hierbei kann gerne auch jeder der Werte unterschieden werden, also über einer Gruppe von Rechnungen steht #Wendepunkte z.B.
     * x_wendepunkte, y_wendepunkte hilft auch enorm dabei eine Übersicht zu haben, also die passenden Wertepaare in ihrer Definition mit ihrem Ursprung benennen
4.  **Plotten der relevanten Werte**
     * Hier gilt das gleiche wie oben (beides hilft stark bei der Fehlerbehebung)
5.  **Eigenschaften des Graphen bestimmen**
     * Legende
     * Grid
     * Achsenbeschriftung
     * Titel des Graphen etc.

<details>
<summary> Klicke HIER, um eine mögliche `function`, die die Fakultät einer beliebigen Zahl bestimmt zu sehen: </summary>

```{pyodide-python}
def fakultaet_berechnen(n):
    # Prüfen, ob die Eingabe eine gültige Zahl ist
    if not isinstance(n, int) or n < 0:
        return "Fehler: Bitte eine nicht-negative ganze Zahl eingeben."
    
    # Basisfall: Die Fakultät von 0 ist 1
    if n == 0:
        return 1
    
    # Berechnung der Fakultät
    ergebnis = 1
    for i in range(1, n + 1):
        ergebnis = ergebnis * i
        
    return ergebnis

# Beispielaufruf der Funktion
zahl = 5
print(f"Die Fakultät von {zahl} ist: {fakultaet_berechnen(zahl)}")
```

</details>


:::

::: {.callout-note title="Dein Analyse Tool: Tipp 2" collapse="true"}
Ein gutes Programm zeichnet sich durch Details und Robustheit aus. Hier sind einige Ideen, wie du dein Tool noch besser machen kannst:

*   **Unterscheide zwischen Hoch- und Tiefpunkten:**
    *   Anstatt alle Extrema in eine Liste zu packen, durchlaufe die gefundenen x-Werte der Extrema in einer Schleife, die die Bedingungen überprüft.
    *   Sortiere die Punkte in separate Listen (z.B. `x_hochpunkte`,  `x_tiefpunkte`,  `y_tiefpunkte`, `x_sattelpunkte`, `y_sattelpunkte`) und plotte sie mit unterschiedlichen Farben oder Markern _Um sie deutlich zu unterscheiden_

*   **Umgang mit möglichen Fehlern:**
    *   Dein Code sollte idealerweise eine Ausgabe haben, die einen Fehler ausgibt, wenn die Funktion von deinem Programm nicht bearbeitet werden kann:

<details>

<summary> Ein Beispiel </summary>

```{pyodide-python}
import sympy

funktion_str = "log(x / (x-1" # Ungültig, da eine Klammer fehlt

try:
    x = sympy.symbols('x')
    f_sym = sympy.sympify(funktion_str)
    print(f"Funktion erfolgreich erstellt: {f_sym}")
except sympy.SympifyError as e:
    print(f"Die Funktion konnte nicht erstellt werden, Fehler war: {e}")
```

</details>

*   **Saubere Textausgabe:**
    *   Es hilft beim Erstellen eines eigenen Codes sehr, die berechneten Werte ausgeben zu lassen, dadurch fällt dir schneller auf, wo der Fehler liegen könnte.
:::

::: {.callout-note title="Dein Analyse Tool: Tipp 3" collapse="true"}
Zielgerade! Die Grundfunktion steht vermutlich bereits, hier sind noch ein paar Tipps, um Dein Programm abzurunden.

*   **Vollständige Text-Analyse:**
    *   Ein Graph ist toll, aber für eine vollständige Kurvendiskussion braucht man auch Text. Plotte nicht nur die Punkte, sondern auch die **Intervalle** für Monotonie und Krümmung.
    *   Vergiss nicht, auch den **Definitions- und Wertebereich** auszugeben! 
*   **Dynamischer und intelligenter Plot-Bereich:**
    *   Anstatt feste `x_min` und `x_max` Werte zu verwenden, passe den Plot-Bereich dynamisch an die Funktion an!
    *   **Idee:** Sammle alle relevanten x-Werte (Nullstellen, Extrema, Wendepunkte). Finde den kleinsten und größten dieser Werte und füge auf beiden Seiten einen kleinen Puffer hinzu (z.B. 20 % des Gesamtbereichs). So stellst du sicher, dass alle wichtigen Merkmale immer gut sichtbar sind, egal welche Funktion analysiert wird.

<details>
<summary> Ein Beispiel für einen Code, der den X-Bereich dynamisch bestimmt </summary>

```{pyodide-python}
# Angenommen, du hast diese Listen mit x-Werten:
nullstellen_x = [0, 3]
extrema_x = [1, 3]
wendepunkte_x = [2]

# Sammle alle x-Werte in einer Liste
alle_x_punkte = nullstellen_x + extrema_x + wendepunkte_x

if alle_x_punkte:
    # Finde min/max und berechne Puffer
    x_min_auto = min(alle_x_punkte)
    x_max_auto = max(alle_x_punkte)
    puffer = (x_max_auto - x_min_auto) * 0.2 # 20% Puffer
    
    # Setze finale Plot-Grenzen
    x_plot_min = x_min_auto - puffer
    x_plot_max = x_max_auto + puffer
else:
    # Fallback, falls keine Punkte gefunden wurden
    x_plot_min = -5
    x_plot_max = 5

print(f"Automatischer Plot-Bereich von {x_plot_min:.2f} bis {x_plot_max:.2f}")

# Diese Werte kannst du dann für np.linspace(x_plot_min, x_plot_max, 400) verwenden.
```

</details>

:::

GRATULATIONEN, wenn du hier angekommen bist, hast du das gesamte Tutorial durchgearbeitet, jetzt solltest du:  
1.  Eine kleine Erinnerung an die Schulmathematik gehabt haben
2.  Die Grundmechaniken von Python verstanden haben
3.  In der Lage sein eine Kurvendiskussion in Python durchzuführen
4.  Auch andere Probleme in Python lösen können indem du die Systeme, die du hier kennengelernt hast, dort anwendest!

Wenn du nicht mal alle Tipps aufmachen musstest, oder beim Öffnen des ein oder anderen Tipps dachtest, "Ach das habe ich doch schon..." dann kannst du Dir getrost auf die Schulter klopfen, das hast du außerordentlich gut gemacht!